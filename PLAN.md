# Plan: Transition ITS-KIDS Server to PostgreSQL with Sequelize

This document outlines the plan to migrate the ITS-KIDS server backend from using a local SQLite database with sample data to a production-ready setup using PostgreSQL managed by the Sequelize ORM.

## Phase 1: Setup Sequelize and PostgreSQL Integration

1.  **Install Dependencies:**
    *   Add necessary Node.js packages to `client/server/package.json`:
        *   `sequelize`: The ORM itself.
        *   `pg`: The PostgreSQL database driver.
        *   `pg-hstore`: Required by Sequelize for PostgreSQL interaction.
        *   `dotenv`: To manage environment variables for configuration.
        *   `sequelize-cli`: For running migrations and seeders.
    *   Run `npm install --prefix client/server`.

2.  **Configure Sequelize:**
    *   Initialize Sequelize CLI: Run `npx sequelize-cli init --prefix client/server`. This will create `config/config.json`, `models/`, `migrations/`, and `seeders/` directories within `client/server`.
    *   Modify `client/server/config/config.json`: Update the `development` and `production` sections to use environment variables for PostgreSQL connection details (host, port, database name, user, password). Use `dotenv` to load these from a `.env` file in development.
    *   Create a `.env` file in `client/server/` for development database credentials. **Add `.env` to `client/server/.gitignore`**.
    *   Update `client/server/models/index.js` (generated by Sequelize CLI) if necessary to load configuration correctly.

## Phase 2: Define Schema and Migrate Data Structure

1.  **Define Sequelize Models:**
    *   Translate the SQLite schema (found in the original `client/server/db/database.js`) into Sequelize model definitions within the `client/server/models/` directory.
    *   Map SQLite data types to appropriate PostgreSQL types (e.g., `TEXT` -> `DataTypes.TEXT` or `DataTypes.STRING`, `INTEGER` -> `DataTypes.INTEGER`, `REAL` -> `DataTypes.FLOAT`, `TIMESTAMP` -> `DataTypes.DATE`, `TEXT` fields storing JSON -> `DataTypes.JSONB`).
    *   Define associations (e.g., `hasMany`, `belongsTo`, `belongsToMany`) between models to represent the foreign key relationships.

2.  **Generate & Run Migrations:**
    *   Use `sequelize-cli` to generate migration files based on the defined models: `npx sequelize-cli migration:generate --name create-tablename --prefix client/server` for each table.
    *   Populate the generated migration files with `queryInterface.createTable(...)` calls, mirroring the model definitions.
    *   Run the migrations against the development PostgreSQL database to create the schema: `npx sequelize-cli db:migrate --prefix client/server`.

## Phase 3: Refactor Application Code

1.  **Update Data Access Logic:**
    *   Modify all database interaction code in `client/server/controllers/` and any remaining in `client/server/index.js`.
    *   Replace raw SQL queries (`db.get`, `db.all`) with Sequelize model methods (e.g., `Student.findByPk()`, `KnowledgeComponent.findAll()`, `Response.create()`).
    *   Ensure associations are used correctly for related data (e.g., `student.getKnowledgeStates()`).

2.  **Update Server Initialization:**
    *   Modify `client/server/index.js` to import and use the Sequelize instance (`db` from `client/server/models/index.js`) instead of the old SQLite connection.
    *   Consider adding a step to test the database connection on startup.

## Phase 4: Cleanup and Finalization

1.  **Remove SQLite Dependencies & Files:**
    *   Uninstall the `sqlite3` package: `npm uninstall sqlite3 --prefix client/server`.
    *   Delete the old database connection file: `client/server/db/database.js`.
    *   Delete the SQLite database file: `client/server/its.db`.
    *   Remove any requires or usage of the old `db` object.

2.  **Remove Sample Data Logic:**
    *   Delete the sample data insertion scripts: `client/server/insertSampleParentData.js`, `client/server/insertSampleTeacherData.js`.
    *   Remove the `initializeSampleData` function and its call from `client/server/index.js`.
    *   Remove the sample data insertion logic from the original `client/server/db/database.js` (already deleted in step 1, but ensure no remnants exist).

3.  **Update `package.json` & `package-lock.json`:** Ensure these files in `client/server/` reflect the changes in dependencies.

## Phase 5: Production Deployment Strategy

1.  **Hosting:**
    *   Select and configure hosting for the Node.js application (e.g., Heroku, AWS, Vercel).
    *   Select and configure hosting for the PostgreSQL database (e.g., AWS RDS, Heroku Postgres, ElephantSQL).

2.  **Environment Variables:**
    *   Set up production environment variables on the hosting platform, including:
        *   `NODE_ENV=production`
        *   PostgreSQL connection details (`DATABASE_URL` or individual variables).
        *   Any required API keys or secrets.

3.  **Deployment Process:**
    *   Establish a build process for the React client (`npm run build` in `client/`).
    *   Configure the Node.js server to serve the static client build.
    *   Set up a deployment pipeline (manual or CI/CD).
    *   **Crucially:** Ensure the deployment process includes a step to run Sequelize migrations (`npx sequelize-cli db:migrate --prefix client/server --env production`) against the production database *before* starting the new application version.

4.  **Security:**
    *   Implement HTTPS.
    *   Configure firewalls for the server and database.
    *   Follow security best practices for Node.js, Express, Sequelize, and PostgreSQL.

5.  **Logging & Monitoring:**
    *   Set up robust server-side logging.
    *   Implement application monitoring and alerting.

6.  **Backups:**
    *   Configure regular automated backups for the production PostgreSQL database.

## Mermaid Diagram

```mermaid
graph TD
    A[Start: SQLite Setup] --> B(Install Sequelize & PG Driver);
    B --> C(Configure Sequelize);
    C --> D(Define Sequelize Models);
    D --> E(Generate Migrations);
    E --> F(Refactor Controllers/Routes);
    F --> G(Remove SQLite Code/Files);
    G --> H(Remove Sample Data Logic);
    H --> I(Setup Prod Env Vars);
    I --> J(Choose Hosting);
    J --> K(Configure Deployment);
    K --> L(Configure Backups/Monitoring);
    L --> M[End: Production Ready on PostgreSQL];